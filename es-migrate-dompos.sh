#!/bin/bash
#
# Created by: Alex
# DESC: Migrata from database to elasticsearch
# =========================================================================


readonly SG_SCRIPT_NAME=$(basename $0)

SG_VERSION=1.0
SG_CONFIG_FILE=""
SG_DRY_RUN="false"
SG_ROLLBACK_MODE="false"

# Flag for debugging
[ -z "$SG_DEBUG" ] && SG_DEBUG="false"

# Migration file suffix
[ -z "$SG_MIGRATE_SUFFIX" ] && SG_MIGRATE_SUFFIX="sg_migrate.esm"

# Default log file
[ -z "$SG_LOG_FILE" ] && SG_LOG_FILE="es-migrate-dompos.log"

# Environment
[ -z "$SG_ENVIRONMENT" ] && SG_ENVIRONMENT="production"

# Function to show the help message
sg_help()
{
    echo "\
Usage: $0 [OPTIONS]

Where OPTIONS:
  -a HOST       Specify URL address of the Elasticsearch server
  -b            Rollback mode
  -c FILE       Specify path of config file
  -e ENVIRON    Environment name, default should be “production”
  -h            Printing the help
  -m NAME       Specify the name of migration file
  -o FILE       save log output to the FILE
  -r            Dry run mode
  -v            Print the version"

}

# Function to display message to inform user to see the help
sg_see_help()
{
    echo "Try '$SG_SCRIPT_NAME -h' for more information."
}

# Try to read from the config file if specified
# We can not use sg_log and sg_err because we still does not know
# the log file
getopts ':c:' SG_CONFIG_OPT
case $SG_CONFIG_OPT in
    c)
        [ "$SG_DEBUG" = "true" ] && echo "DEBUG: Using config file ${OPTARG}."
        [ -f "$OPTARG" ] || {
            echo "ERROR: Config file $OPTARG is not found." >&2
            exit 2
        }

        source "$OPTARG"
    ;;

    \?)
        # Do nothing
    ;;
esac

# We want another getopts to parse arguments so we reset OPTIND
OPTIND=1

# Function to output syslog like output
sg_write_log()
{
    SG_LOG_MESSAGE="$@"
    SG_SYSLOG_DATE_STYLE=$( date +"%b %e %H:%M:%S" )
    SG_HOSTNAME=$( hostname )
    SG_PID=$$

    # Date Hostname AppName[PID]: MESSAGE
    printf "%s %s %s[%s]: %s\n" \
        "$SG_SYSLOG_DATE_STYLE" \
        "$SG_HOSTNAME" \
        "$SG_SCRIPT_NAME" \
        "$SG_PID" \
        "${SG_LOG_MESSAGE}">> "$SG_LOG_FILE"
}

# Function to log message
sg_log()
{
    [ "$SG_DEBUG" = "true" ] && echo "DEBUG: $@"
    sg_write_log "$@"
}

sg_err() {
    echo "ERROR: $@" >&2
    sg_write_log "$@"
    sg_see_help
}

# Function to compare files between migrated v migration directory
sg_compare_dir()
{
    # Diff will output something like:
    # ```
    # Only in tools/migrated/env_name: file_x.INDEX
    # Only in tools/migrations: file_y.INDEX
    # ```
    # We are only interest the output which says 'only in MIGRATED_DIR/ENV_NAME'
    # because it means that these files is not migrated yet.
    SG_ENV_MIGRATED_DIR="$SG_MIGRATED_DIR/$SG_ENVIRONMENT"
    diff -q "$SG_ENV_MIGRATED_DIR" "$SG_MIGRATION_DIR" | grep "^Only in $SG_MIGRATION_DIR" | \
    awk -F': ' '{print $2}' | sort
}

# Function to initialize elastic config
sg_init_elestic_config()
{
    [ -z "$SG_ELASTICS_HOST" ] && {
        sg_err "Please specify the Elasticsearch server name in -a option, SG_ELASTICS_HOST environment or in config."
        exit 2
    }
    sg_log "Using index name ${SG_ELASTICS_HOST}."
}

# Function to initialize common config
sg_init_migrate()
{
    # Directory used to store the INDEX schema migration
    [ -z "$SG_MIGRATION_DIR" ] && SG_MIGRATION_DIR="migrations"

    [ -d "$SG_MIGRATION_DIR" ] || {
        sg_err "Failed to find the migrations: $SG_MIGRATION_DIR directory."
        exit 2
    }
    sg_log "Migration directory is set to ${SG_MIGRATION_DIR}."

    [ -z "$SG_MIGRATED_DIR" ] && SG_MIGRATED_DIR="migrated"

    [ -d "$SG_MIGRATED_DIR" ] || {
        sg_err "Failed to find the migrated: $SG_MIGRATED_DIR directory."
        exit 2
    }
    sg_log "Migrated directory is set to ${SG_MIGRATED_DIR}"

    [ -z "$SG_ROLLBACK_DIR" ] && SG_ROLLBACK_DIR="rollback"

    [ -d "$SG_ROLLBACK_DIR" ] || {
        sg_err "Failed to find the rollback: $SG_ROLLBACK_DIR directory."
        exit 2
    }
    sg_log "Rollback directory is set to ${SG_ROLLBACK_DIR}."
}

# Function to create the INDEX migration file
function sg_create_migration_file()
{
    local SG_DATE_RFC2822=$( date )
    local SG_NOW=$( date +"%Y_%m_%d_%H_%M_%S" )
    local SG_MIG_NAME=$( echo "$1" | tr '[:upper:]' '[:lower:]' )
    local SG_FILE_NAME=$( printf "%s_%s.%s" "$SG_NOW" "$SG_MIG_NAME" "$SG_MIGRATE_SUFFIX" )

    sg_init_migrate

    echo "\
## es-migrate-dompos Migration Script
## Generated by: es-migrate-dompos v${SG_VERSION}
## File: $SG_FILE_NAME
## Date: $SG_DATE_RFC2822
## Write your INDEX migration below this line" > "$SG_MIGRATION_DIR/$SG_FILE_NAME" || {
        sg_err "Failed to create file $SG_MIGRATION_DIR/${SG_FILE_NAME}."
        exit sh $SG_MIGRATION_DIR/$file 2>&1 >/dev/null
    }

    echo "\
## es-migrate-dompos Rollback Script
## Generated by: es-migrate-dompos v${SG_VERSION}
## File: $SG_FILE_NAME
## Date: $SG_DATE_RFC2822
## Write your INDEX rolllback migration below this line" > "$SG_ROLLBACK_DIR/$SG_FILE_NAME" || {
        sg_err "Failed to create file $SG_ROLLBACK_DIR/${SG_FILE_NAME}."
        exit 2
    }

    echo "Migration file: $SG_MIGRATION_DIR/${SG_FILE_NAME}."
    echo "Rollback file: $SG_ROLLBACK_DIR/${SG_FILE_NAME}."
}

# Function to migrate the schema by executing all the files in migrations
# directory which does not exists on migrated directory
sg_migrate()
{
    sg_init_elestic_config
    sg_init_migrate
    ES_SERVER=$SG_ELASTICS_HOST


    # Create the environment directory inside the migrated dir
    sg_log "Creating directory $SG_MIGRATED_DIR/$SG_ENVIRONMENT if not exists."
    mkdir -p "$SG_MIGRATED_DIR/$SG_ENVIRONMENT" 2>/dev/null || {
        sg_err "Can not create directory $SG_MIGRATED_DIR/${SG_ENVIRONMENT}."
    }

    SG_COUNTER=0
    for file in $( sg_compare_dir )
    do
        SG_COUNTER=$(( $SG_COUNTER + 1 ))
        echo -n "Migrating $file..."
        if [ "$SG_DRY_RUN" == "true" ]; then
            echo "done dry run."
            echo ">> Contents of file $SG_MIGRATION_DIR/${file}: "

            awk '{ gsub("{{ES_SERVER}}","'${ES_SERVER}'");print }' $SG_MIGRATION_DIR/$file  && echo ""

            continue
        fi

        sg_log "Running command: sh $SG_MIGRATION_DIR/$file 2>&1 >/dev/null"
        SG_IMPORT_ERROR=`awk '{ gsub("{{ES_SERVER}}","'${ES_SERVER}'");print}' $SG_MIGRATION_DIR/$file|sh 2>/dev/null`
        success=`echo $SG_IMPORT_ERROR|wc -m`
        #echo $success this only using debugging
        if [ $success -eq 22 ]; then
            echo "done migrate."

            # Copy the rollback content to the migrated directory
            awk '{ gsub("{{ES_SERVER}}","'${ES_SERVER}'")}' $SG_ROLLBACK_DIR/$file > "$SG_MIGRATED_DIR/$SG_ENVIRONMENT/$file"
        else
            echo "failed migrate."
            sg_err "Failed migrating $SG_MIGRATION_DIR/$file with message: $SG_IMPORT_ERROR "
            exit 3
        fi
    done

    [ $SG_COUNTER -eq 0 ] && echo "Nothing to migrate."
}

# Function to rollback the schema which already migrated
sg_rollback()
{
    sg_init_elestic_config
    sg_init_migrate
    ES_SERVER=$SG_ELASTICS_HOST

    sg_log "Getting list of rollback files in $SG_MIGRATED_DIR/$SG_ENVIRONMENT directory."
    SG_COUNTER=0
    for file in $( ls $SG_MIGRATED_DIR/$SG_ENVIRONMENT 2>/dev/null | sort -r | head -1 )
    do
        SG_COUNTER=$(( $SG_COUNTER + 1 ))
        echo -n "Rollback ${file}..."

        if [ "$SG_DRY_RUN" == "true" ]; then
            echo "done."
            echo ">> Contents of file $SG_MIGRATED_DIR/$SG_ENVIRONMENT/${file}: "
            awk '{ gsub("{{ES_SERVER}}","'${ES_SERVER}'"); print }' $SG_MIGRATED_DIR/$SG_ENVIRONMENT/$file && echo ""

            continue
        fi

        sg_log "Running command: Rollback Elastic < $SG_MIGRATED_DIR/$SG_ENVIRONMENT/$file 2>&1 >/dev/null"
        SG_ROLLBACK_ERROR=`awk '{ gsub("{{ES_SERVER}}","'${ES_SERVER}'"); print }' $SG_MIGRATION_DIR/$file|sh 2>/dev/null`
        success=`echo $SG_IMPORT_ERROR|wc -m`
        if [ $success -eq 22 ]; then
            echo "done."

            # Remove the file, so it can be rerun again in the future
            rm "$SG_MIGRATED_DIR/$SG_ENVIRONMENT/$file"
        else
            echo "failed."
            sg_err "Failed rolling back $SG_MIGRATED_DIR/$SG_ENVIRONMENT/$file with message: $SG_ROLLBACK_ERROR"
            exit 3
        fi
    done

    [ $SG_COUNTER -eq 0 ] && echo "Nothing to rollback."
}

# Parse the arguments
while getopts c:a:be:hm:rv SG_OPT;
do
    case $SG_OPT in
        a)
            SG_ELASTICS_HOST="$OPTARG"
            SG_DO_MIGRATION="true"
        ;;

        b)
            SG_ROLLBACK_MODE="true"
            SG_DO_MIGRATION="true"
        ;;

        e)
            SG_ENVIRONMENT="$OPTARG"
            SG_DO_MIGRATION="true"
        ;;

        h)
            sg_help
            exit 0
        ;;

        m)
            sg_create_migration_file "$OPTARG"
        ;;

        r)
            sg_log "Running in DRY RUN mode"
            SG_DRY_RUN="true"
            SG_DO_MIGRATION="true"
        ;;

        v)
            echo "es-migrate-dompos version ${SG_VERSION}."
            exit 0
        ;;

        \?)
            sg_help
            exit 1
        ;;
    esac
done

# No argument given
[ $# -eq 0 ] && SG_DO_MIGRATION="true"

if [ "$SG_DO_MIGRATION" == "true" ]; then
    if [ "$SG_ROLLBACK_MODE" == "false" ]; then
      sg_migrate
    else
        sg_rollback
    fi
fi
